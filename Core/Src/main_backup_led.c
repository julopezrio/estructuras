/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32 VS Code Extension
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stm32l4xx_my_rcc.h>
#include <stm32l4xx_my_systick.h>
#include <stm32l4xx_my_gpio.h>

// Habilita interrupciones globales
void EnableGlobalInterrupts(void)
{
    __asm volatile("CPSIE i" ::: "memory");
}


#define LED_PORT GPIOA_BASE
#define LED_PIN 5

// Definir los estados de la FSM
typedef enum {
    STATE_LED_OFF,
    STATE_LED_ON
} LED_State_t;

// Variables globales
LED_State_t current_state = STATE_LED_OFF;


int main(void)
{
    // Habilitar relojes
    RCC_EnableAPB2(0x1); // Ejemplo: habilitar periféricos de APB2
    
    // Iniciliza el reloj del sistema 1ms para clk = 4MHz
    SysTick_Init(3999);

    // Habilita interrupciones globales
    EnableGlobalInterrupts();
    
    // Habilita el reloj de los puertos necesarios
    RCC_EnableAHB2(RCC_GPIOA_ENABLE | RCC_GPIOB_ENABLE | RCC_GPIOC_ENABLE);

    // Configurar GPIOA (pin 5 como salida)
    GPIO_SetPinAsOutput(LED_PORT, LED_PIN);

    GPIO_SetPin(LED_PORT, LED_PIN);   // Encender LED
    GPIO_ClearPin(LED_PORT, LED_PIN); // Apagar LED

    uint32_t last_tick = 0;
    // Bucle infinito
    while (1)
    {
        if ((SysTick_GetTick() - last_tick) >= 500)
        {
            last_tick = SysTick_GetTick();
            switch (current_state) 
            {
                case STATE_LED_OFF:
                    //GPIO_TogglePin(LED_PORT, LED_PIN);   // Cambiar de estado LED
                     GPIO_SetPin(LED_PORT, LED_PIN);   // Encender LED
                    current_state = STATE_LED_ON;
                    break;

                case STATE_LED_ON:
                    //GPIO_TogglePin(LED_PORT, LED_PIN);   // Cambiar de estado LED
                    GPIO_ClearPin(LED_PORT, LED_PIN); // Apagar LED 
                    current_state = STATE_LED_OFF;
                    break;

                default:
                    // Estado inválido (reiniciar a un estado conocido)
                    current_state = STATE_LED_OFF;
                    break;
            }
        }
    }

    return 0;
}
/**/
